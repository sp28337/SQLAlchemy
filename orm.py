from sqlalchemy import select

from database import get_db_session
from orm_models import User

session = get_db_session()

# Чтобы завершить основные операции по сохранению, отдельный объект ORM может быть помечен для удаления в рамках
# единицы рабочего процесса с помощью Session.delete() метода. Давайте загрузим patrick из базы данных:

patrick = session.get(User, 3)

# Если мы помечаем данные patrick для удаления, как в случае с другими операциями,
# то на самом деле ничего не происходит, пока не будет выполнен Flash:

session.delete(patrick)

print("-" * 60)
# Текущее поведение ORM таково, что он patrick остается в памяти Session до тех пор,
# пока не будет выполнен сброс, который, как упоминалось ранее, происходит, если мы выдаем запрос:

session.execute(select(User).where(User.name == "patrick")).first()

# Выше, SELECT, который мы просили выдать, предшествовал DELETE, что указывало на ожидающее удаление для patrick
# продолжения. Также был SELECT против address таблицы, который был вызван ORM, ищущим строки в этой таблице,
# которые могут быть связаны с целевой строкой; это поведение является частью поведения, известного как каскад,
# и может быть настроено для более эффективной работы, позволяя базе данных address автоматически обрабатывать
# связанные строки; раздел удаления содержит все подробности об этом.

# Помимо этого, patrick удаляемый экземпляр объекта больше не
# считается постоянным внутри Session, как показывает проверка включения:

print(patrick in session)

# Однако, как и UPDATE, которые мы сделали для sandy объекта, каждое изменение, которое мы сделали здесь,
# является локальным для текущей транзакции, которая не станет постоянной, если мы ее не зафиксируем.
# Поскольку откат транзакции на самом деле более интересен в данный момент, мы сделаем это в следующем разделе.
print(patrick.__dict__)
session.rollback()
print(patrick.__dict__)
print(patrick.fullname)
print(patrick.__dict__)

session.close()

