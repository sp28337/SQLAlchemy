from database import get_db_session
from orm_models import User

squidward = User(name="squidward", fullname="Squidward Tentacles")
krabs = User(name="ehkrabs", fullname="Eugene H. Krabs")
session = get_db_session()
session.add(squidward)
session.add(krabs)
session.flush()
print("-" * 60)
# После вставки строк два созданных нами объекта Python находятся в состоянии, известном как persistent, в котором
# они связаны с Session объектом, в котором они были добавлены или загружены, и обладают множеством других поведений,
# которые будут рассмотрены позже.

# Другим эффектом произошедшего INSERT стало то, что ORM извлек новые идентификаторы первичного ключа для каждого
# нового объекта; внутри он обычно использует тот же CursorResult.inserted_primary_key метод доступа, который мы ввели
# ранее. Теперь объекты squidward и krabs имеют эти новые идентификаторы первичного ключа, связанные с ними,
# и мы можем просмотреть их, обратившись к id атрибуту:

print(squidward.id)
print(krabs.id)

# Почему ORM выдает два отдельных оператора INSERT, когда он мог бы использовать executemany? Как мы увидим в следующем
# разделе, Session при очистке объектов всегда необходимо знать первичный ключ вновь вставленных объектов.
# Если используется такая функция, как автоинкремент SQLite (другие примеры включают PostgreSQL IDENTITY или SERIAL,
# использование последовательностей и т. д.), эта CursorResult.inserted_primary_key функция обычно требует,
# чтобы каждый INSERT выдавал одну строку за раз. Если бы мы заранее предоставили значения для первичных ключей,
# ORM смог бы лучше оптимизировать операцию. Некоторые бэкэнды баз данных, такие как psycopg2, также могут вставлять
# много строк одновременно, при этом все еще имея возможность извлекать значения первичного ключа.

