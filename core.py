from sqlalchemy import select, func

from core_models import *
from database import get_db_engine
from orm_models import User, Address

engine = get_db_engine()


# В SQL агрегатные функции позволяют объединять выражения столбцов в нескольких строках для получения
# единого результата. Примерами являются подсчет, вычисление средних значений, а также поиск максимального или
# минимального значения в наборе значений.
#
# SQLAlchemy предоставляет функции SQL открытым способом, используя пространство имен, известное как func.
# Это специальный объект-конструктор, который будет создавать новые экземпляры Function при указании имени конкретной
# функции SQL, которая может иметь любое имя, а также ноль или более аргументов для передачи в функцию,
# которые, как и во всех других случаях, являются конструкциями выражений SQL. Например, чтобы отобразить
# функцию SQL COUNT() для столбца user_account.id, мы вызываем count() имя:

count_fn = func.count(user_table.c.id)
print(count_fn)

print("-" * 60)
# При использовании агрегатных функций в SQL предложение GROUP BY имеет важное значение, поскольку оно позволяет
# разбивать строки на группы, где агрегатные функции будут применяться к каждой группе по отдельности.
# При запросе неагрегированных столбцов в предложении COLUMNS оператора SELECT SQL требует,
# чтобы все эти столбцы подчинялись предложению GROUP BY, либо напрямую, либо косвенно на основе первичной
# ключевой ассоциации. Предложение HAVING затем используется аналогично предложению WHERE, за исключением того,
# что оно отфильтровывает строки на основе агрегированных значений, а не прямого содержимого строк.
#
# SQLAlchemy предоставляет эти два предложения с использованием методов Select.group_by() и Select.having().
# Ниже мы иллюстрируем выбор полей имени пользователя, а также количества адресов для тех пользователей,
# которые имеют более одного адреса:

with engine.connect() as conn:
    result = conn.execute(
        select(User.name, func.count(Address.id).label("count"))
        .join(Address)
        .group_by(User.name)
        .having(func.count(Address.id) > 1)
    )
    print(result.all())
